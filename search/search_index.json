{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Confkit","text":"<p>Lightweight, type-safe configuration via descriptors on plain Python classes.</p> <p>This landing page orients you quickly:</p> Topic Where to Go Run examples Examples section (navigation) or Examples overview Create a custom data type Usage Guide: Adding a New Data Type See all data type converters Reference: Data Types Decorator utilities Usage: Decorators Overview API by symbol Generated API (pdoc) Contribute / issues GitHub Repo: HEROgold/confkit"},{"location":"#examples","title":"Examples","text":"<p>Explore focused example pages:</p> <ul> <li>Basic primitives &amp; persistence: <code>Basic</code></li> <li>Data types (hex, octal, binary, bases): <code>Data types</code></li> <li>Optional &amp; cascading configs: <code>Optional values</code></li> <li>Lists &amp; escaping: <code>List types</code></li> <li>Enums &amp; flags: <code>Enums</code></li> <li>Decorator injection patterns: <code>Decorators</code></li> <li>Argparse integration: <code>Argparse</code></li> <li>Custom converter (UpperString): Custom Data Type</li> </ul> <p>Need a new scenario? Open an issue or PR (see Contributing below).</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome:</p> <ol> <li>Additional data type converters</li> <li>Validation enhancements and edge-case handling</li> <li>Improved documentation examples / tutorials</li> <li>Bug reports with minimal reproduction scripts</li> </ol> <p>Workflow (after forking or a feature branch):</p> <pre><code>uv sync --group dev\nuv run pytest -q\nuv run ruff check .\nuv sync --group docs\nuv run pdoc confkit -o docs/api\nuv run mkdocs build -d site\n</code></pre> <p>Before opening a PR, ensure:</p> <ul> <li>All tests pass (including property-based tests)</li> <li>No ruff or type errors (pyright config in project)</li> <li>Updated docs where behavior changed</li> </ul>"},{"location":"#supported-python-versions","title":"Supported Python Versions","text":"<p>confkit follows the Python version support policy as outlined in the Python Developer's Guide:</p> <ul> <li>We support all active and maintenance releases of Python above 3.11</li> <li>End-of-life (EOL) Python versions are not supported</li> <li>We aim to support Python release candidates to stay ahead of the release cycle</li> </ul> <p>This ensures that confkit remains compatible with current Python versions while allowing us to leverage modern language features.</p>"},{"location":"#api-reference","title":"API Reference","text":"<p>Two complementary views:</p>"},{"location":"#high-level-curated-reference-pages","title":"High-level curated reference pages","text":"<ul> <li>Config</li> <li>Data Types</li> <li>Exceptions</li> </ul>"},{"location":"#full-symbol-index-pdoc","title":"Full symbol index (pdoc)","text":"<p>confkit API</p> <p>Use <code>(pdoc:qual.name)</code> style links inside docs for deep, stable symbol links</p> <pre><code>The [MyClass](!!! Unresolved path to: mypackage.MyClass) class is awesome.\nThe [do_something](!!! Unresolved path to: mypackage.MyClass.do_something) method is awesome.\nThe [](mypackage.MyClass) class is awesome.\n</code></pre>"},{"location":"#when-to-use-confkit","title":"When to Use confkit","text":"<p>Use confkit when you want:</p> <ul> <li>Simple, configuration management</li> <li>Type conversion and validation baked in</li> <li>Declarative, descriptor-based definitions instead of manual parsing</li> </ul> <p>If you need hierarchical, nested config trees or schema evolution with migrations, pair confkit with a higher-level orchestrator or consider extending with custom data types.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Head to the Usage Guide for deeper patterns, or jump straight into an Example.</p>"},{"location":"usage/","title":"Usage","text":"<p>This page explains how to work with confkit and how the documentation is generated.</p>"},{"location":"usage/#descriptor-quickstart","title":"Descriptor Quickstart","text":"<pre><code>from configparser import ConfigParser\nfrom pathlib import Path\nfrom confkit import Config\n\n# 1. Configure confkit parser/file (normally app bootstrap)\nparser = ConfigParser()\nConfig.set_parser(parser)\nConfig.set_file(Path(\"config.ini\"))\n\n# 2. Define your (class)variables with their default values\nclass AppConfig:\n    debug = Config(False)\n    port = Config(8080)\n\n# 3. use them!\n# (this value came from the .ini file!) \nprint(AppConfig.port)\n</code></pre>"},{"location":"usage/#adding-a-new-data-type","title":"Adding a New Data Type","text":"<ol> <li>Subclass <code>BaseDataType[T]</code></li> <li>Implement <code>convert(self, value: str) -&gt; T</code></li> <li>(Optional) override <code>__str__</code> for serialization</li> <li>Use via <code>Config(CustomType(default_value))</code></li> </ol> <pre><code>from configparser import ConfigParser\nfrom pathlib import Path\nfrom confkit import Config\nfrom confkit.data_types import BaseDataType\n\n# 1. Configure confkit parser/file (normally app bootstrap)\nparser = ConfigParser()\nConfig.set_parser(parser)\nConfig.set_file(Path(\"config.ini\"))\n\n# 2. Define the custom converter, with a convert method (from str -&gt; your_type)\nclass UpperString(BaseDataType[str]):\n    def convert(self, value: str) -&gt; str:  # str from INI -&gt; normalized value\n        return str(value).upper()\n\n    def __str__(self, value: str):  # value -&gt; string for INI\n        return value.upper()\n\n# 3. Use the custom datatype inside a config class\nclass CustomCfg:\n    shout_name = Config(UpperString(\"confkit\"))\n\nprint(CustomCfg.shout_name)  # -&gt; CONFKIT\nCustomCfg.shout_name = \"mixedCase\"\nprint(CustomCfg.shout_name)  # -&gt; MIXEDCASE\n</code></pre> <p>Full runnable example: <code>examples/custom_data_type.py</code>.</p>"},{"location":"usage/#optional-values","title":"Optional Values","text":"<p>Either pass <code>optional=True</code> to <code>Config(...)</code> or wrap a data type in <code>Optional(...)</code>.</p> <pre><code>from confkit.data_types import Optional, String\n\nclass Service:\n    api_key = Config(\"\", optional=True)                    # primitive optional\n    token = Config(Optional(String(\"\")))                   # wrapped optional\n</code></pre>"},{"location":"usage/#decorators-overview","title":"Decorators Overview","text":"<ul> <li><code>Config.set(section, option, value)</code> \u2013 always sets before call</li> <li><code>Config.default(section, option, value)</code> \u2013 sets only when missing</li> <li><code>Config.with_setting(descriptor)</code> \u2013 injects descriptor value by name</li> <li><code>Config.with_kwarg(section, option, name?, default?)</code> \u2013 inject by strings</li> </ul> <p>See also: the dedicated reference pages for cross-linked signatures.</p>"},{"location":"usage/#regenerating-api-docs-pdoc-mkdocs","title":"Regenerating API Docs (pdoc + mkdocs)","text":"<p>The documentation is using both <code>mkdocstrings</code> and the <code>mkdocs-pdoc-plugin</code> for deep API symbol cross-references. The <code>api/</code> directory inside <code>docs-mkdocs/</code> is produced by <code>pdoc</code>. Regenerate it after changing code-level docstrings or adding new public classes/functions.</p> <pre><code>uv run pdoc confkit -o docs-mkdocs/api --force\n</code></pre> <p>Key points:</p> <ol> <li><code>--force</code> overwrites existing output</li> <li>The MkDocs plugin (configured in <code>mkdocs.yml</code> as <code>pdoc: { api_path: api }</code>) enables links like <code>(pdoc:confkit.config.Config)</code> inside Markdown</li> <li>Reference pages in <code>reference/</code> intentionally use those links for stable deep-links</li> </ol>"},{"location":"examples/","title":"Examples Overview","text":"<p>This section provides runnable examples demonstrating how to use confkit in different scenarios. Each example page includes:</p> <ul> <li>Purpose &amp; concepts demonstrated</li> <li>Required setup (if any)</li> <li>How to run the example</li> <li>Expected / generated <code>.ini</code> configuration contents</li> <li>Notes &amp; variations you can try</li> </ul>"},{"location":"examples/#quick-start-running-examples","title":"Quick Start: Running Examples","text":"<p>All examples assume you are in the project root and have dependencies installed (only the library itself is needed for runtime examples):</p> <pre><code>uv run python examples/basic.py\n</code></pre> <p>If you are editing examples and want immediate persistence, remember that <code>Config.write_on_edit</code> defaults to <code>True</code> unless explicitly disabled.</p>"},{"location":"examples/#example-categories","title":"Example Categories","text":"Category Examples Concepts Core Usage Basic Descriptor access, automatic type handling Data Types Data Types Explicit + formatted numeric types, custom bases Optional &amp; Fallbacks Optional Values Nullable values, fallbacks, cascading configs Lists List Types Escaping, separators, heterogeneous-like usage Enums Enums StrEnum, IntEnum, IntFlag, optional enum values Decorators Decorators Injecting config into functions argparse Integration Argparse CLI defaults + config separation <p>Select an example in the navigation to dive in.</p>"},{"location":"examples/argparse/","title":"Argparse Integration Example (<code>argparse_example.py</code>)","text":""},{"location":"examples/argparse/#purpose","title":"Purpose","text":"<p>Shows how to combine CLI argument parsing with confkit-backed defaults while keeping runtime-provided values separate from persisted configuration.</p>"},{"location":"examples/argparse/#key-concepts","title":"Key Concepts","text":"<ul> <li>Use descriptors to define defaults (<code>AppConfig</code>)</li> <li>Reuse those defaults when defining CLI args</li> <li>Disable write-on-edit (<code>Config.write_on_edit = False</code>) to avoid persisting transient CLI overrides</li> <li>Maintain a clean separation between runtime arguments and persistent config</li> </ul>"},{"location":"examples/argparse/#running","title":"Running","text":"<pre><code>uv run python examples/argparse_example.py --host 0.0.0.0 --port 9090 --debug --tags alpha beta\n</code></pre>"},{"location":"examples/argparse/#generated-files","title":"Generated Files","text":"<p>Only <code>config.ini</code> is used for the descriptors; CLI values are not written because <code>write_on_edit</code> is disabled.</p> <p>Example baseline (first run):</p> <pre><code>[AppConfig]\ndebug = False\nhost = 127.0.0.1\nport = 8000\ntags = example,demo\n</code></pre> <p>After running with overrides, the file remains unchanged (transient values do not persist):</p> <pre><code>[AppConfig]\ndebug = False\nhost = 127.0.0.1\nport = 8000\ntags = example,demo\n</code></pre>"},{"location":"examples/argparse/#notes","title":"Notes","text":"<ul> <li>If you enable <code>Config.write_on_edit = True</code>, assignments to descriptors (not argparse inputs) will persist.</li> <li>You can sync back only selected CLI values by explicitly assigning them to descriptors after parsing.</li> </ul>"},{"location":"examples/argparse/#try-variations","title":"Try Variations","text":"<ul> <li>Manually edit <code>config.ini</code> default port and re-run with a different CLI value.</li> <li>Set <code>write_on_edit = True</code> temporarily and manually assign <code>AppConfig.port = args.port</code> after parsing.</li> </ul>"},{"location":"examples/basic/","title":"Basic Example (<code>basic.py</code>)","text":""},{"location":"examples/basic/#purpose","title":"Purpose","text":"<p>Demonstrates the foundational usage of <code>confkit</code>:</p> <ul> <li>Setting a parser + backing file</li> <li>Defining a config class with different primitive types</li> <li>Automatic persistence via <code>Config.write_on_edit</code></li> <li>Accessing &amp; mutating values via descriptor access</li> </ul>"},{"location":"examples/basic/#code-summary","title":"Code Summary","text":"<p><code>examples/basic.py</code> defines <code>AppConfig</code> with boolean, int, string, float, and optional string fields.</p>"},{"location":"examples/basic/#running","title":"Running","text":"<pre><code>uv run python examples/basic.py\n</code></pre> <p>If <code>config.ini</code> does not yet exist it will be created automatically.</p>"},{"location":"examples/basic/#generated-updated-configini","title":"Generated / Updated <code>config.ini</code>","text":"<p>A first run typically produces something like:</p> <pre><code>[AppConfig]\ndebug = False\nport = 8080\nhost = localhost\ntimeout = 30.5\napi_key = \n</code></pre> <p>After the script executes (it changes <code>port</code> and sets <code>api_key</code>), the file becomes:</p> <pre><code>[AppConfig]\ndebug = False\nport = 9000\nhost = localhost\ntimeout = 30.5\napi_key = my-secret-key\n</code></pre>"},{"location":"examples/basic/#try-variations","title":"Try Variations","text":"<ul> <li>Set <code>Config.write_on_edit = False</code> and observe that changes are not written.</li> <li>Manually edit <code>config.ini</code> then re-run to see those values picked up.</li> </ul>"},{"location":"examples/basic/#key-takeaways","title":"Key Takeaways","text":"<p>The descriptor interface gives you type-safe access. Mutations immediately persist (when enabled) without needing manual write calls.</p>"},{"location":"examples/custom_data_type/","title":"Custom Data Type (<code>custom_data_type.py</code>)","text":""},{"location":"examples/custom_data_type/#purpose","title":"Purpose","text":"<p>Shows how to create and use a custom <code>BaseDataType</code> implementation.</p> <ul> <li>Normalize and persist a value in a consistent representation</li> <li>Demonstrate the required <code>convert</code> method</li> <li>(Optionally) override <code>__str__</code> for serialization formatting</li> </ul>"},{"location":"examples/custom_data_type/#implementation","title":"Implementation","text":"<pre><code>from configparser import ConfigParser\nfrom pathlib import Path\nfrom confkit import Config\nfrom confkit.data_types import BaseDataType\n\n# Configure parser + file\nparser = ConfigParser()\nConfig.set_parser(parser)\nConfig.set_file(Path(\"config.ini\"))\n\nclass UpperString(BaseDataType[str]):\n    \"\"\"String that is always stored / returned in UPPER CASE.\"\"\"\n    def convert(self, value: str) -&gt; str:  # raw INI -&gt; normalized\n        return str(value).upper()\n\n    def __str__(self, value: str):  # normalized -&gt; persisted string\n        return value.upper()\n\nclass CustomCfg:\n    shout_name = Config(UpperString(\"confkit\"))\n\nprint(CustomCfg.shout_name)  # CONFKIT\nCustomCfg.shout_name = \"MixedCase\"\nprint(CustomCfg.shout_name)  # MIXEDCASE\n</code></pre>"},{"location":"examples/custom_data_type/#generated-file-snippet","title":"Generated File Snippet","text":"<p>After the first run (values normalized):</p> <pre><code>[CustomCfg]\nshout_name = CONFKIT\n</code></pre> <p>After reassignment:</p> <pre><code>[CustomCfg]\nshout_name = MIXEDCASE\n</code></pre>"},{"location":"examples/custom_data_type/#design-notes","title":"Design Notes","text":"<ul> <li><code>convert</code> should raise an appropriate exception (let <code>BaseDataType.validate</code> help if you call it) when input cannot be parsed.</li> <li>Override <code>validate</code> if you need domain rules (e.g. length limits). Call <code>super().validate()</code> if stacking behavior.</li> <li><code>__str__</code> mainly matters when you want the persisted form to differ from <code>str(value)</code>.</li> </ul>"},{"location":"examples/custom_data_type/#integration-checklist","title":"Integration Checklist","text":"<ol> <li>Create subclass <code>class X(BaseDataType[T]):</code></li> <li>Implement <code>convert(self, value: str) -&gt; T</code></li> <li>(Optional) override <code>__str__(self, value: T) -&gt; str</code></li> <li>(Optional) override <code>validate(self, value: T)</code> for domain constraints.</li> <li>Use with <code>Config(X(default_value))</code></li> </ol>"},{"location":"examples/custom_data_type/#related-docs","title":"Related Docs","text":"<ul> <li>Usage Guide: Adding a New Data Type</li> <li>Reference: Data Types</li> <li>Source example: <code>examples/custom_data_type.py</code></li> </ul>"},{"location":"examples/data_types/","title":"Data Types Example (<code>data_types.py</code>)","text":""},{"location":"examples/data_types/#purpose","title":"Purpose","text":"<p>Showcases the breadth of built-in and helper data types:</p> <ul> <li>Explicit vs implicit (auto-detected) types</li> <li>Numeric formatting (Hex, Octal, Binary)</li> <li>Custom base integers (encoded as <code>&lt;base&gt;c&lt;value&gt;</code> in the file)</li> <li>Bytes \u2192 integer conversion via <code>Binary</code></li> </ul>"},{"location":"examples/data_types/#running","title":"Running","text":"<pre><code>uv run python examples/data_types.py\n</code></pre>"},{"location":"examples/data_types/#generated-configini-excerpt","title":"Generated <code>config.ini</code> (Excerpt)","text":"<p>Values may accumulate across runs; representative first-run section:</p> <pre><code>[DataTypeConfig]\nstring_value = default string\nint_value = 42\nfloat_value = 3.14159\nbool_value = True\nauto_string = auto-detected string\nauto_int = 100\nauto_float = 2.71828\nauto_bool = False\nhex_value = 0xff\noctal_value = 0o755\nbinary_value = 0b10101010\nbinary_from_bytes = 0b0110100001100101011011000110110001101111\nbase7_value = 7c42\nbase5_value = 5c13\n</code></pre> <p>After updates inside the script, the file reflects the new values (hex, octal, binary adjustments).</p>"},{"location":"examples/data_types/#notes","title":"Notes","text":"<ul> <li>Changing <code>base</code> persists a prefixed representation so it can be reliably parsed later.</li> <li><code>Binary</code> will store integers; when constructed from <code>bytes</code>, those bytes are interpreted as a big-endian integer.</li> <li><code>Hex</code> normalizes values by dropping leading zeros (e.g. <code>0x000f</code> becomes <code>0xf</code>).</li> </ul>"},{"location":"examples/data_types/#try-variations","title":"Try Variations","text":"<ul> <li>Manually edit <code>hex_value</code> to <code>0x1a2b</code> and re-run.</li> <li>Remove <code>binary_from_bytes</code> line; script re-creates it.</li> </ul>"},{"location":"examples/data_types/#custom-type-extension","title":"Custom Type Extension","text":"<p>See the separate custom data type example <code>examples/custom_data_type.py</code> for how to implement and register your own converter (e.g. an <code>UpperString</code> normalizer) by subclassing <code>BaseDataType</code>.</p>"},{"location":"examples/decorators/","title":"Decorators Example (<code>decorators.py</code>)","text":""},{"location":"examples/decorators/#purpose","title":"Purpose","text":"<p>Shows how to inject configuration values into functions using decorators:</p> <ul> <li><code>@Config.with_setting(descriptor)</code> \u2014 injects kwarg named after descriptor</li> <li><code>@Config.with_kwarg(section, option, kwarg_name, default)</code> \u2014 inject by strings + custom kwarg name</li> </ul>"},{"location":"examples/decorators/#running","title":"Running","text":"<pre><code>uv run python examples/decorators.py\n</code></pre>"},{"location":"examples/decorators/#behavior","title":"Behavior","text":"<p><code>ServiceConfig.retry_count</code> and <code>ServiceConfig.timeout</code> are standard descriptors. The decorators wrap the functions so when called, kwargs contain the current config values.</p>"},{"location":"examples/decorators/#example-output-first-run","title":"Example Output (first run)","text":"<pre><code>Processing with 3 retries\n</code></pre>"},{"location":"examples/decorators/#notes","title":"Notes","text":"<ul> <li>The <code>with_kwarg</code> variant does not require direct descriptor reference (less type-safe, more flexible).</li> <li>You can still override the injected kwarg manually when calling the function; manual kwargs win.</li> </ul>"},{"location":"examples/decorators/#try-variations","title":"Try Variations","text":"<ul> <li>Replace <code>with_kwarg</code> with <code>with_setting</code> referencing a different descriptor.</li> </ul>"},{"location":"examples/enums/","title":"Enums Example (<code>enums.py</code>)","text":""},{"location":"examples/enums/#purpose","title":"Purpose","text":"<p>Demonstrates enum support:</p> <ul> <li><code>StrEnum</code>, <code>IntEnum</code>, <code>IntFlag</code>, usage via dedicated data types</li> <li>Optional enum values</li> <li>Bitwise flag composition (<code>Permission</code>)</li> <li>Self-documenting config files with inline comments showing all allowed enum values</li> </ul>"},{"location":"examples/enums/#running","title":"Running","text":"<pre><code>uv run python examples/enums.py\n</code></pre>"},{"location":"examples/enums/#generated-configini-excerpt","title":"Generated <code>config.ini</code> (Excerpt)","text":"<pre><code>[ServerConfig]\nlog_level = info  # allowed: debug, info, warning, error\ndefault_priority = 5  # allowed: LOW(0), MEDIUM(5), HIGH(10)\ndefault_permission = 1  # allowed: READ(1), WRITE(2), EXECUTE(4)\nfallback_level = error  # allowed: debug, info, warning, error\nenvironment = INFO  # allowed: DEBUG, INFO, WARNING, ERROR\n</code></pre> <p>Notice how each enum value now includes an inline comment listing all possible values. This makes configuration files self-documenting for end-users who may not be familiar with the codebase.</p> <p>If values are changed in code (or by assignment at runtime) they persist accordingly, and the allowed values comment is automatically maintained.</p>"},{"location":"examples/enums/#notes","title":"Notes","text":"<ul> <li>Allowed values are automatically displayed: Enum values include inline comments showing all valid options</li> <li>Format varies by enum type:</li> <li><code>StrEnum</code>: Shows member values (e.g., <code>debug, info, warning, error</code>)</li> <li><code>IntEnum</code>/<code>IntFlag</code>: Shows member names with values (e.g., <code>LOW(0), MEDIUM(5), HIGH(10)</code>)</li> <li><code>Enum</code>: Shows member names (e.g., <code>DEBUG, INFO, WARNING, ERROR</code>)</li> <li><code>IntFlag</code> values are stored as their integer bitfield representation</li> <li>Optional enum fields removed (set to <code>None</code>) disappear from the file</li> <li>Comments are automatically stripped when reading values, so they don't interfere with parsing</li> </ul>"},{"location":"examples/enums/#try-variations","title":"Try Variations","text":"<ul> <li>Manually set <code>default_permission = 7</code> (READ|WRITE|EXECUTE) and re-run - the allowed values comment will be preserved.</li> <li>Set <code>fallback_level =</code> (blank) then inspect its loaded value (<code>None</code>).</li> </ul>"},{"location":"examples/list_types/","title":"List Types Example (<code>list_types.py</code>)","text":""},{"location":"examples/list_types/#purpose","title":"Purpose","text":"<p>Shows how to work with list-based configuration values:</p> <ul> <li>Storing homogeneous lists of primitives</li> <li>Escaping separators &amp; special characters</li> <li>Empty elements and explicit typed empty lists</li> </ul>"},{"location":"examples/list_types/#running","title":"Running","text":"<pre><code>uv run python examples/list_types.py\n</code></pre>"},{"location":"examples/list_types/#generated-configini-excerpt","title":"Generated <code>config.ini</code> (Excerpt)","text":"<pre><code>[ListConfig]\nstring_list = red,green,blue\nint_list = 1,2,3,4,5\nfloat_list = 1.1,2.2,3.3,4.4\nbool_list = True,False,True\npaths_list = /path/to/file1,C:\\\\path\\\\to\\\\file2\ncomplex_list = item1,item\\,with\\,commas,normal item\nwith_empty = ,middle,\nempty_list = \n</code></pre>"},{"location":"examples/list_types/#notes","title":"Notes","text":"<ul> <li>See <code>List.separator</code> and <code>List.escape_char</code> for their default values (explicitly set in the example for clarity).</li> <li>Items containing the separator are escaped when written, then unescaped on read.</li> <li>An explicit empty list with a declared data type stays as a blank line after the equals sign.</li> </ul>"},{"location":"examples/list_types/#try-variations","title":"Try Variations","text":"<ul> <li>Append a value manually to <code>int_list</code> in the file and re-run.</li> <li>Add a value containing a backslash and observe escaping.</li> </ul>"},{"location":"examples/optional_values/","title":"Optional Values Example (<code>optional_values.py</code>)","text":""},{"location":"examples/optional_values/#purpose","title":"Purpose","text":"<p>Demonstrates nullable / optional configuration patterns:</p> <ul> <li><code>optional=True</code> shorthand vs <code>Optional(...)</code> wrapper</li> <li>Optional enums, strings, integers</li> <li>Empty string vs None semantics</li> <li>Cascading defaults &amp; fallback logic</li> </ul>"},{"location":"examples/optional_values/#running","title":"Running","text":"<pre><code>uv run python examples/optional_values.py\n</code></pre>"},{"location":"examples/optional_values/#generated-configini-excerpt","title":"Generated <code>config.ini</code> (Excerpt)","text":"<p>First run (only defaults materialize):</p> <pre><code>[OptionalConfig]\ndatabase_url = sqlite:///app.db\nlog_file = app.log\nworker_count = 4\noptional_string = default\noptional_int = 42\noptional_enum = dev\napi_key = \nsecret_key = \n\n[DatabaseConfig]\nconnection_string = sqlite:///fallback.db\nusername = \npassword = \nport = 5432\n</code></pre> <p>After code mutates values or sets some to <code>None</code>, lines representing <code>None</code> are removed (or may remain absent if never set). When assigning new values, those lines reappear.</p> <p>Example after updates:</p> <pre><code>[OptionalConfig]\ndatabase_url = \nlog_file = \nworker_count = \noptional_string = new value\noptional_int = 100\noptional_enum = prod\napi_key = \nsecret_key = \n\n[DatabaseConfig]\nconnection_string = postgresql://localhost/mydb\nusername = admin\npassword = \nport = 5433\n</code></pre>"},{"location":"examples/optional_values/#notes","title":"Notes","text":"<ul> <li>Setting a value to <code>None</code> for an optional field removes it from the config file.</li> <li>Empty string <code>\"\"</code> is distinct from <code>None</code> (still persisted as a blank value).</li> <li>Use fallback logic in application code (see <code>get_connection_params</code>).</li> </ul>"},{"location":"examples/optional_values/#try-variations","title":"Try Variations","text":"<ul> <li>Remove the whole <code>[DatabaseConfig]</code> section and re-run.</li> <li>Set <code>worker_count = None</code> then reassign an integer.</li> </ul>"},{"location":"reference/config/","title":"Config Descriptor","text":"<p>This section provides curated guidance around the core <code>Config</code> descriptor and its decorators. For full auto-generated API documentation see the pdoc pages linked via the <code>pdoc:</code> references below.</p>"},{"location":"reference/config/#core-class","title":"Core Class","text":"<ul> <li><code>Config</code> \u2013 Descriptor managing reading/writing typed values.</li> </ul>"},{"location":"reference/config/#lifecycle-initialization-helpers","title":"Lifecycle / Initialization Helpers","text":"<ul> <li><code>Config.set_parser</code></li> <li><code>Config.set_file</code></li> <li><code>Config.write</code></li> </ul>"},{"location":"reference/config/#runtime-flags","title":"Runtime Flags","text":"<ul> <li><code>Config.validate_types</code></li> <li><code>Config.write_on_edit</code></li> </ul>"},{"location":"reference/config/#decorators","title":"Decorators","text":"<ul> <li><code>Config.set</code> \u2013 Always set a value before calling a function.</li> <li><code>Config.default</code> \u2013 Set only when unset.</li> <li><code>Config.with_setting</code> \u2013 Inject an existing descriptor value as a kwarg.</li> <li><code>Config.with_kwarg</code> \u2013 (Named <code>with_kwarg</code> in code; often described as <code>with_kwarg</code>) inject by section/setting with optional rename &amp; default.</li> </ul>"},{"location":"reference/config/#internal-validation-selected","title":"Internal Validation (Selected)","text":"<ul> <li><code>Config.validate_file</code></li> <li><code>Config.validate_parser</code></li> <li><code>Config.validate_strict_type</code></li> </ul> <p>Tip: Use the decorators for imperative flows and prefer descriptor attributes for normal configuration access. </p>"},{"location":"reference/config/#class-vs-instance-access","title":"Class vs Instance Access","text":"<p>Reading configuration values works the same whether you access a <code>Config</code> descriptor from the class or from an instance, but setting behaves differently and is important to understand:</p> <ul> <li>Reading: You may read values using either the class or an instance.</li> <li>Example: <code>AppConfig.debug</code> and <code>AppConfig().debug</code> will both return the current value.</li> <li>Setting: To write a value back through the <code>Config</code> descriptor you must assign on an instance.</li> <li>Example: <code>cfg = AppConfig(); cfg.debug = True</code> will persist the descriptor.</li> <li>Assigning to <code>AppConfig.debug = True</code> (class-level assignment) does not go through the instance write-path and therefore will not behave like an instance write, overriding the entire descriptor.</li> </ul> <p>If you need class-level assignment semantics (so that <code>AppConfig.debug = True</code> updates configuration), use the provided metaclass <code>ConfigContainerMeta</code>. This metaclass adjusts container behavior so class access can be used for setting values. See <code>tests/test_metaclass.py</code> for a concrete example of using <code>ConfigContainerMeta</code> in the test-suite.</p>"},{"location":"reference/data_types/","title":"Data Types","text":"<p>confkit uses a family of small converter classes to provide type safety and round\u2011trip serialization.</p>"},{"location":"reference/data_types/#base-type","title":"Base Type","text":"<ul> <li><code>BaseDataType</code></li> <li><code>BaseDataType.convert</code></li> <li><code>BaseDataType.validate</code></li> <li><code>BaseDataType.cast</code></li> <li><code>BaseDataType.cast_optional</code></li> </ul>"},{"location":"reference/data_types/#primitive-converters","title":"Primitive Converters","text":"<ul> <li><code>String</code></li> <li><code>Integer</code></li> <li><code>Float</code></li> <li><code>Boolean</code></li> <li><code>NoneType</code></li> </ul>"},{"location":"reference/data_types/#enum-converters","title":"Enum Converters","text":"<ul> <li><code>Enum</code></li> <li><code>StrEnum</code></li> <li><code>IntEnum</code></li> <li><code>IntFlag</code></li> </ul> <p>All enum types automatically display allowed values as inline comments in the config file, making them self-documenting for end-users. For example:</p> <pre><code>log_level = info  # allowed: debug, info, warning, error\n</code></pre> <p>The format varies by enum type: - StrEnum: Shows member values (e.g., <code>debug, info, warning, error</code>) - IntEnum/IntFlag: Shows member names with integer values (e.g., <code>LOW(0), MEDIUM(5), HIGH(10)</code>) - Enum: Shows member names (e.g., <code>DEBUG, INFO, WARNING, ERROR</code>)</p> <p>Comments are automatically stripped when reading values, ensuring they don't interfere with parsing.</p>"},{"location":"reference/data_types/#number-representation-helpers","title":"Number Representation Helpers","text":"<ul> <li><code>Hex</code></li> <li><code>Octal</code></li> <li><code>Binary</code></li> </ul>"},{"location":"reference/data_types/#optional-composite","title":"Optional &amp; Composite","text":"<ul> <li><code>Optional</code></li> <li><code>List</code></li> </ul> <p>Design note: <code>Optional</code> wraps another <code>BaseDataType</code> and returns <code>None</code> when a null sentinel is parsed.</p>"},{"location":"reference/data_types/#collections","title":"Collections","text":"<ul> <li><code>Tuple</code></li> <li><code>Set</code></li> <li><code>Dict</code></li> </ul> <p><code>Tuple</code>, <code>Set</code>, and <code>Dict</code> mirror their built\u2011in counterparts. Allowing for collections to be stored in INI files.</p>"},{"location":"reference/data_types/#date-time","title":"Date &amp; Time","text":"<ul> <li><code>DateTime</code></li> <li><code>Date</code></li> <li><code>Time</code></li> <li><code>TimeDelta</code></li> </ul> <p><code>DateTime</code>, <code>Date</code>, <code>Time</code> and <code>TimeDelta</code> mirror their built-in counterparts. Allowing to store date information in INI files.</p>"},{"location":"reference/data_types/#custom-type-example","title":"Custom Type Example","text":"<ul> <li><code>BaseDataType</code></li> </ul>"},{"location":"reference/exceptions/","title":"Exceptions","text":"<p>The library raises a small, focused set of exceptions for invalid defaults and converter errors.</p> <ul> <li><code>InvalidDefaultError</code></li> <li><code>InvalidConverterError</code></li> </ul> <p>These both subclass <code>ValueError</code> to keep failure modes familiar while allowing precise catching.</p>"},{"location":"reference/notes_two_instances/","title":"Multiple Instances Behavior","text":"<ul> <li>Test reference: <code>tests/test_two_instances.py</code> \u2014 verifies that two instances of the same <code>Config</code>-container class observe the same values and that the descriptor-level <code>on_file_change</code> handler is invoked when the backing file is updated.</li> <li>Singleton-like behavior: When multiple instances are created from the same config-container class, they share the underlying parser and descriptor state. Mutating a value through one instance (or via the descriptor) is observable from the other instance; this is effectively a shared/singleton configuration surface backed by a single parser.</li> <li>Descriptor-level hooks: <code>on_file_change</code> is attached to the descriptor (not per-instance) in the test. This means file-change callbacks are shared across instances of the same config class and will fire when the <code>FileWatcher</code> indicates the file has changed.</li> <li>Practical implication: Treat config-container classes as views over a shared configuration store. Writes performed on any instance or via the descriptor update the shared parser and (when enabled) persist to the configured file.</li> </ul>"}]}