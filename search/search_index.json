{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Confkit","text":"<p>Lightweight, type-safe configuration via descriptors on plain Python classes.</p> <p>This landing page orients you quickly:</p> Topic Where to Go Run examples Examples section (navigation) or Examples overview Create a custom data type Usage Guide: Adding a New Data Type See all data type converters Reference: Data Types Decorator utilities Usage: Decorators Overview API by symbol Generated API (pdoc) Contribute / issues GitHub Repo: HEROgold/confkit"},{"location":"#examples","title":"Examples","text":"<p>Explore focused example pages:</p> <ul> <li>Basic primitives &amp; persistence: <code>Basic</code></li> <li>Data types (hex, octal, binary, bases): <code>Data types</code></li> <li>Optional &amp; cascading configs: <code>Optional values</code></li> <li>Lists &amp; escaping: <code>List types</code></li> <li>Enums &amp; flags: <code>Enums</code></li> <li>Decorator injection patterns: <code>Decorators</code></li> <li>Argparse integration: <code>Argparse</code></li> <li>Custom converter (UpperString): Custom Data Type</li> </ul> <p>Need a new scenario? Open an issue or PR (see Contributing below).</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome:</p> <ol> <li>Additional data type converters</li> <li>Validation enhancements and edge-case handling</li> <li>Improved documentation examples / tutorials</li> <li>Bug reports with minimal reproduction scripts</li> </ol> <p>Workflow (after forking or a feature branch):</p> <pre><code>uv sync --group dev\nuv run pytest -q\nuv run ruff check .\nuv sync --group docs\nuv run pdoc confkit -o docs/api\nuv run mkdocs build -d site\n</code></pre> <p>Before opening a PR, ensure:</p> <ul> <li>All tests pass (including property-based tests)</li> <li>No ruff or type errors (pyright config in project)</li> <li>Updated docs where behavior changed</li> </ul>"},{"location":"#supported-python-versions","title":"Supported Python Versions","text":"<p>confkit follows the Python version support policy as outlined in the Python Developer's Guide:</p> <ul> <li>We support all active and maintenance releases of Python above 3.11</li> <li>End-of-life (EOL) Python versions are not supported</li> <li>We aim to support Python release candidates to stay ahead of the release cycle</li> </ul> <p>This ensures that confkit remains compatible with current Python versions while allowing us to leverage modern language features.</p>"},{"location":"#api-reference","title":"API Reference","text":"<p>Two complementary views:</p>"},{"location":"#high-level-curated-reference-pages","title":"High-level curated reference pages","text":"<ul> <li>Config</li> <li>Data Types</li> <li>Exceptions</li> </ul>"},{"location":"#full-symbol-index-pdoc","title":"Full symbol index (pdoc)","text":"<p>confkit API</p> <p>Use <code>(pdoc:qual.name)</code> style links inside docs for deep, stable symbol links</p> <pre><code>The [MyClass](!!! Unresolved path to: mypackage.MyClass) class is awesome.\nThe [do_something](!!! Unresolved path to: mypackage.MyClass.do_something) method is awesome.\nThe [](mypackage.MyClass) class is awesome.\n</code></pre>"},{"location":"#when-to-use-confkit","title":"When to Use confkit","text":"<p>Use confkit when you want:</p> <ul> <li>Simple, configuration management</li> <li>Type conversion and validation baked in</li> <li>Declarative, descriptor-based definitions instead of manual parsing</li> </ul> <p>If you need hierarchical, nested config trees or schema evolution with migrations, pair confkit with a higher-level orchestrator or consider extending with custom data types.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Head to the Usage Guide for deeper patterns, or jump straight into an Example.</p>"},{"location":"usage/","title":"Usage","text":"<p>This page explains how to work with confkit and how the documentation is generated.</p>"},{"location":"usage/#descriptor-quickstart","title":"Descriptor Quickstart","text":"<pre><code>from configparser import ConfigParser\nfrom pathlib import Path\nfrom confkit import Config\n\n# 1. Configure confkit parser/file (normally app bootstrap)\nparser = ConfigParser()\nConfig.set_parser(parser)\nConfig.set_file(Path(\"config.ini\"))\n\n# 2. Define your (class)variables with their default values\nclass AppConfig:\n    debug = Config(False)\n    port = Config(8080)\n\n# 3. use them!\n# (this value came from the .ini file!) \nprint(AppConfig.port)\n</code></pre>"},{"location":"usage/#adding-a-new-data-type","title":"Adding a New Data Type","text":"<ol> <li>Subclass <code>BaseDataType[T]</code></li> <li>Implement <code>convert(self, value: str) -&gt; T</code></li> <li>(Optional) override <code>__str__</code> for serialization</li> <li>Use via <code>Config(CustomType(default_value))</code></li> </ol> <pre><code>from configparser import ConfigParser\nfrom pathlib import Path\nfrom confkit import Config\nfrom confkit.data_types import BaseDataType\n\n# 1. Configure confkit parser/file (normally app bootstrap)\nparser = ConfigParser()\nConfig.set_parser(parser)\nConfig.set_file(Path(\"config.ini\"))\n\n# 2. Define the custom converter, with a convert method (from str -&gt; your_type)\nclass UpperString(BaseDataType[str]):\n    def convert(self, value: str) -&gt; str:  # str from INI -&gt; normalized value\n        return str(value).upper()\n\n    def __str__(self, value: str):  # value -&gt; string for INI\n        return value.upper()\n\n# 3. Use the custom datatype inside a config class\nclass CustomCfg:\n    shout_name = Config(UpperString(\"confkit\"))\n\nprint(CustomCfg.shout_name)  # -&gt; CONFKIT\nCustomCfg.shout_name = \"mixedCase\"\nprint(CustomCfg.shout_name)  # -&gt; MIXEDCASE\n</code></pre> <p>Full runnable example: <code>examples/custom_data_type.py</code>.</p>"},{"location":"usage/#optional-values","title":"Optional Values","text":"<p>Either pass <code>optional=True</code> to <code>Config(...)</code> or wrap a data type in <code>Optional(...)</code>.</p> <pre><code>from confkit.data_types import Optional, String\n\nclass Service:\n    api_key = Config(\"\", optional=True)                    # primitive optional\n    token = Config(Optional(String(\"\")))                   # wrapped optional\n</code></pre>"},{"location":"usage/#decorators-overview","title":"Decorators Overview","text":"<ul> <li><code>Config.set(section, option, value)</code> \u2013 always sets before call</li> <li><code>Config.default(section, option, value)</code> \u2013 sets only when missing</li> <li><code>Config.with_setting(descriptor)</code> \u2013 injects descriptor value by name</li> <li><code>Config.with_kwarg(section, option, name?, default?)</code> \u2013 inject by strings</li> </ul> <p>See also: the dedicated reference pages for cross-linked signatures.</p>"},{"location":"usage/#regenerating-api-docs-pdoc-mkdocs","title":"Regenerating API Docs (pdoc + mkdocs)","text":"<p>The documentation is using both <code>mkdocstrings</code> and the <code>mkdocs-pdoc-plugin</code> for deep API symbol cross-references. The <code>api/</code> directory inside <code>docs-mkdocs/</code> is produced by <code>pdoc</code>. Regenerate it after changing code-level docstrings or adding new public classes/functions.</p> <pre><code>uv run pdoc confkit -o docs-mkdocs/api --force\n</code></pre> <p>Key points:</p> <ol> <li><code>--force</code> overwrites existing output</li> <li>The MkDocs plugin (configured in <code>mkdocs.yml</code> as <code>pdoc: { api_path: api }</code>) enables links like <code>(pdoc:confkit.config.Config)</code> inside Markdown</li> <li>Reference pages in <code>reference/</code> intentionally use those links for stable deep-links</li> </ol>"},{"location":"examples/","title":"Examples Overview","text":"<p>This section provides runnable examples demonstrating how to use confkit in different scenarios. Each example page includes:</p> <ul> <li>Purpose &amp; concepts demonstrated</li> <li>Required setup (if any)</li> <li>How to run the example</li> <li>Expected / generated <code>.ini</code> configuration contents</li> <li>Notes &amp; variations you can try</li> </ul>"},{"location":"examples/#quick-start-running-examples","title":"Quick Start: Running Examples","text":"<p>All examples assume you are in the project root and have dependencies installed (only the library itself is needed for runtime examples):</p> <pre><code>uv run python examples/basic.py\n</code></pre> <p>If you are editing examples and want immediate persistence, remember that <code>Config.write_on_edit</code> defaults to <code>True</code> unless explicitly disabled.</p>"},{"location":"examples/#example-categories","title":"Example Categories","text":"Category Examples Concepts Core Usage Basic Descriptor access, automatic type handling Data Types Data Types Explicit + formatted numeric types, custom bases Optional &amp; Fallbacks Optional Values Nullable values, fallbacks, cascading configs Lists List Types Escaping, separators, heterogeneous-like usage Enums Enums StrEnum, IntEnum, IntFlag, optional enum values Decorators Decorators Injecting config into functions argparse Integration Argparse CLI defaults + config separation <p>Select an example in the navigation to dive in.</p>"},{"location":"examples/argparse/","title":"Argparse Integration Example (<code>argparse_example.py</code>)","text":""},{"location":"examples/argparse/#purpose","title":"Purpose","text":"<p>Shows how to combine CLI argument parsing with confkit-backed defaults while keeping runtime-provided values separate from persisted configuration.</p>"},{"location":"examples/argparse/#key-concepts","title":"Key Concepts","text":"<ul> <li>Use descriptors to define defaults (<code>AppConfig</code>)</li> <li>Reuse those defaults when defining CLI args</li> <li>Disable write-on-edit (<code>Config.write_on_edit = False</code>) to avoid persisting transient CLI overrides</li> <li>Maintain a clean separation between runtime arguments and persistent config</li> </ul>"},{"location":"examples/argparse/#running","title":"Running","text":"<pre><code>uv run python examples/argparse_example.py --host 0.0.0.0 --port 9090 --debug --tags alpha beta\n</code></pre>"},{"location":"examples/argparse/#generated-files","title":"Generated Files","text":"<p>Only <code>config.ini</code> is used for the descriptors; CLI values are not written because <code>write_on_edit</code> is disabled.</p> <p>Example baseline (first run):</p> <pre><code>[AppConfig]\ndebug = False\nhost = 127.0.0.1\nport = 8000\ntags = example,demo\n</code></pre> <p>After running with overrides, the file remains unchanged (transient values do not persist):</p> <pre><code>[AppConfig]\ndebug = False\nhost = 127.0.0.1\nport = 8000\ntags = example,demo\n</code></pre>"},{"location":"examples/argparse/#notes","title":"Notes","text":"<ul> <li>If you enable <code>Config.write_on_edit = True</code>, assignments to descriptors (not argparse inputs) will persist.</li> <li>You can sync back only selected CLI values by explicitly assigning them to descriptors after parsing.</li> </ul>"},{"location":"examples/argparse/#try-variations","title":"Try Variations","text":"<ul> <li>Manually edit <code>config.ini</code> default port and re-run with a different CLI value.</li> <li>Set <code>write_on_edit = True</code> temporarily and manually assign <code>AppConfig.port = args.port</code> after parsing.</li> </ul>"},{"location":"examples/basic/","title":"Basic Example (<code>basic.py</code>)","text":""},{"location":"examples/basic/#purpose","title":"Purpose","text":"<p>Demonstrates the foundational usage of <code>confkit</code>:</p> <ul> <li>Setting a parser + backing file</li> <li>Defining a config class with different primitive types</li> <li>Automatic persistence via <code>Config.write_on_edit</code></li> <li>Accessing &amp; mutating values via descriptor access</li> </ul>"},{"location":"examples/basic/#code-summary","title":"Code Summary","text":"<p><code>examples/basic.py</code> defines <code>AppConfig</code> with boolean, int, string, float, and optional string fields.</p>"},{"location":"examples/basic/#running","title":"Running","text":"<pre><code>uv run python examples/basic.py\n</code></pre> <p>If <code>config.ini</code> does not yet exist it will be created automatically.</p>"},{"location":"examples/basic/#generated-updated-configini","title":"Generated / Updated <code>config.ini</code>","text":"<p>A first run typically produces something like:</p> <pre><code>[AppConfig]\ndebug = False\nport = 8080\nhost = localhost\ntimeout = 30.5\napi_key = \n</code></pre> <p>After the script executes (it changes <code>port</code> and sets <code>api_key</code>), the file becomes:</p> <pre><code>[AppConfig]\ndebug = False\nport = 9000\nhost = localhost\ntimeout = 30.5\napi_key = my-secret-key\n</code></pre>"},{"location":"examples/basic/#try-variations","title":"Try Variations","text":"<ul> <li>Comment out <code>Config.write_on_edit = True</code> (or set to <code>False</code>) and observe that changes are not written.</li> <li>Manually edit <code>config.ini</code> then re-run to see values picked up.</li> </ul>"},{"location":"examples/basic/#key-takeaways","title":"Key Takeaways","text":"<p>The descriptor interface gives you type-safe access. Mutations immediately persist (when enabled) without needing manual write calls.</p>"},{"location":"examples/custom_data_type/","title":"Custom Data Type (<code>custom_data_type.py</code>)","text":""},{"location":"examples/custom_data_type/#purpose","title":"Purpose","text":"<p>Shows how to create and use a custom <code>BaseDataType</code> implementation.</p> <ul> <li>Normalize and persist a value in a consistent representation</li> <li>Demonstrate the required <code>convert</code> method</li> <li>(Optionally) override <code>__str__</code> for serialization formatting</li> </ul>"},{"location":"examples/custom_data_type/#implementation","title":"Implementation","text":"<pre><code>from configparser import ConfigParser\nfrom pathlib import Path\nfrom confkit import Config\nfrom confkit.data_types import BaseDataType\n\n# Configure parser + file\nparser = ConfigParser()\nConfig.set_parser(parser)\nConfig.set_file(Path(\"config.ini\"))\n\nclass UpperString(BaseDataType[str]):\n    \"\"\"String that is always stored / returned in UPPER CASE.\"\"\"\n    def convert(self, value: str) -&gt; str:  # raw INI -&gt; normalized\n        return str(value).upper()\n\n    def __str__(self, value: str):  # normalized -&gt; persisted string\n        return value.upper()\n\nclass CustomCfg:\n    shout_name = Config(UpperString(\"confkit\"))\n\nprint(CustomCfg.shout_name)  # CONFKIT\nCustomCfg.shout_name = \"MixedCase\"\nprint(CustomCfg.shout_name)  # MIXEDCASE\n</code></pre>"},{"location":"examples/custom_data_type/#generated-file-snippet","title":"Generated File Snippet","text":"<p>After the first run (values normalized):</p> <pre><code>[CustomCfg]\nshout_name = CONFKIT\n</code></pre> <p>After reassignment:</p> <pre><code>[CustomCfg]\nshout_name = MIXEDCASE\n</code></pre>"},{"location":"examples/custom_data_type/#design-notes","title":"Design Notes","text":"<ul> <li><code>convert</code> should raise an appropriate exception (let <code>BaseDataType.validate</code> help if you call it) when input cannot be parsed.</li> <li>Override <code>validate</code> if you need domain rules (e.g. length limits). Call <code>super().validate()</code> if stacking behavior.</li> <li><code>__str__</code> mainly matters when you want the persisted form to differ from <code>str(value)</code>.</li> </ul>"},{"location":"examples/custom_data_type/#integration-checklist","title":"Integration Checklist","text":"<ol> <li>Create subclass <code>class X(BaseDataType[T]):</code></li> <li>Implement <code>convert(self, value: str) -&gt; T</code></li> <li>(Optional) override <code>__str__(self, value: T) -&gt; str</code></li> <li>(Optional) override <code>validate(self, value: T)</code> for domain constraints.</li> <li>Use with <code>Config(X(default_value))</code></li> </ol>"},{"location":"examples/custom_data_type/#related-docs","title":"Related Docs","text":"<ul> <li>Usage Guide: Adding a New Data Type</li> <li>Reference: Data Types</li> <li>Source example: <code>examples/custom_data_type.py</code></li> </ul>"},{"location":"examples/data_types/","title":"Data Types Example (<code>data_types.py</code>)","text":""},{"location":"examples/data_types/#purpose","title":"Purpose","text":"<p>Showcases the breadth of built-in and helper data types:</p> <ul> <li>Explicit vs implicit (auto-detected) types</li> <li>Numeric formatting (Hex, Octal, Binary)</li> <li>Custom base integers (encoded as <code>&lt;base&gt;c&lt;value&gt;</code> in the file)</li> <li>Bytes \u2192 integer conversion via <code>Binary</code></li> </ul>"},{"location":"examples/data_types/#running","title":"Running","text":"<pre><code>uv run python examples/data_types.py\n</code></pre>"},{"location":"examples/data_types/#generated-configini-excerpt","title":"Generated <code>config.ini</code> (Excerpt)","text":"<p>Values may accumulate across runs; representative first-run section:</p> <pre><code>[DataTypeConfig]\nstring_value = default string\nint_value = 42\nfloat_value = 3.14159\nbool_value = True\nauto_string = auto-detected string\nauto_int = 100\nauto_float = 2.71828\nauto_bool = False\nhex_value = 0xff\noctal_value = 0o755\nbinary_value = 0b10101010\nbinary_from_bytes = 0b0110100001100101011011000110110001101111\nbase7_value = 7c42\nbase5_value = 5c13\n</code></pre> <p>After updates inside the script, the file reflects the new values (hex, octal, binary adjustments).</p>"},{"location":"examples/data_types/#notes","title":"Notes","text":"<ul> <li>Changing <code>base</code> persists a prefixed representation so it can be reliably parsed later.</li> <li><code>Binary</code> will store integers; when constructed from <code>bytes</code>, those bytes are interpreted as a big-endian integer.</li> </ul>"},{"location":"examples/data_types/#try-variations","title":"Try Variations","text":"<ul> <li>Manually edit <code>hex_value</code> to <code>0x1a2b</code> and re-run.</li> <li>Remove <code>binary_from_bytes</code> line; script re-creates it.</li> </ul>"},{"location":"examples/data_types/#custom-type-extension","title":"Custom Type Extension","text":"<p>See the separate custom data type example <code>examples/custom_data_type.py</code> for how to implement and register your own converter (e.g. an <code>UpperString</code> normalizer) by subclassing <code>BaseDataType</code>.</p>"},{"location":"examples/decorators/","title":"Decorators Example (<code>decorators.py</code>)","text":""},{"location":"examples/decorators/#purpose","title":"Purpose","text":"<p>Shows how to inject configuration values into functions using decorators:</p> <ul> <li><code>@Config.with_setting(descriptor)</code> \u2014 injects kwarg named after descriptor</li> <li><code>@Config.with_kwarg(section, option, kwarg_name, default)</code> \u2014 inject by strings + custom kwarg name</li> </ul>"},{"location":"examples/decorators/#running","title":"Running","text":"<pre><code>uv run python examples/decorators.py\n</code></pre>"},{"location":"examples/decorators/#behavior","title":"Behavior","text":"<p><code>ServiceConfig.retry_count</code> and <code>ServiceConfig.timeout</code> are standard descriptors. The decorators wrap the functions so when called, kwargs contain the current config values.</p>"},{"location":"examples/decorators/#example-output-first-run","title":"Example Output (first run)","text":"<pre><code>Processing with 3 retries\n</code></pre>"},{"location":"examples/decorators/#notes","title":"Notes","text":"<ul> <li>The <code>with_kwarg</code> variant does not require direct descriptor reference (less type-safe, more flexible).</li> <li>You can still override the injected kwarg manually when calling the function; manual kwargs win.</li> </ul>"},{"location":"examples/decorators/#try-variations","title":"Try Variations","text":"<ul> <li>Replace <code>with_kwarg</code> with <code>with_setting</code> referencing a different descriptor.</li> </ul>"},{"location":"examples/enums/","title":"Enums Example (<code>enums.py</code>)","text":""},{"location":"examples/enums/#purpose","title":"Purpose","text":"<p>Demonstrates enum support:</p> <ul> <li><code>StrEnum</code>, <code>IntEnum</code>, <code>IntFlag</code>, usage via dedicated data types</li> <li>Optional enum values</li> <li>Bitwise flag composition (<code>Permission</code>)</li> </ul>"},{"location":"examples/enums/#running","title":"Running","text":"<pre><code>uv run python examples/enums.py\n</code></pre>"},{"location":"examples/enums/#generated-configini-excerpt","title":"Generated <code>config.ini</code> (Excerpt)","text":"<pre><code>[ServerConfig]\nlog_level = info\ndefault_priority = 5\ndefault_permission = 1\nfallback_level = error\nenvironment = info\n</code></pre> <p>If values are changed in code (or by assignment at runtime) they persist accordingly.</p>"},{"location":"examples/enums/#notes","title":"Notes","text":"<ul> <li><code>IntFlag</code> values are stored as their integer bitfield representation.</li> <li>Optional enum fields removed (set to <code>None</code>) disappear from the file.</li> </ul>"},{"location":"examples/enums/#try-variations","title":"Try Variations","text":"<ul> <li>Manually set <code>default_permission = 7</code> (READ|WRITE|EXECUTE) and re-run.</li> <li>Set <code>fallback_level =</code> (blank) then inspect its loaded value (<code>None</code>).</li> </ul>"},{"location":"examples/list_types/","title":"List Types Example (<code>list_types.py</code>)","text":""},{"location":"examples/list_types/#purpose","title":"Purpose","text":"<p>Shows how to work with list-based configuration values:</p> <ul> <li>Storing homogeneous lists of primitives</li> <li>Escaping separators &amp; special characters</li> <li>Empty elements and explicit typed empty lists</li> </ul>"},{"location":"examples/list_types/#running","title":"Running","text":"<pre><code>uv run python examples/list_types.py\n</code></pre>"},{"location":"examples/list_types/#generated-configini-excerpt","title":"Generated <code>config.ini</code> (Excerpt)","text":"<pre><code>[ListConfig]\nstring_list = red,green,blue\nint_list = 1,2,3,4,5\nfloat_list = 1.1,2.2,3.3,4.4\nbool_list = True,False,True\npaths_list = /path/to/file1,C:\\\\path\\\\to\\\\file2\ncomplex_list = item1,item\\,with\\,commas,normal item\nwith_empty = ,middle,\nempty_list = \n</code></pre>"},{"location":"examples/list_types/#notes","title":"Notes","text":"<ul> <li>See <code>List.separator</code> and <code>List.escape_char</code> for their default values (explicitly set in the example for clarity).</li> <li>Items containing the separator are escaped when written, then unescaped on read.</li> <li>An explicit empty list with a declared data type stays as a blank line after the equals sign.</li> </ul>"},{"location":"examples/list_types/#try-variations","title":"Try Variations","text":"<ul> <li>Append a value manually to <code>int_list</code> in the file and re-run.</li> <li>Add a value containing a backslash and observe escaping.</li> </ul>"},{"location":"examples/optional_values/","title":"Optional Values Example (<code>optional_values.py</code>)","text":""},{"location":"examples/optional_values/#purpose","title":"Purpose","text":"<p>Demonstrates nullable / optional configuration patterns:</p> <ul> <li><code>optional=True</code> shorthand vs <code>Optional(...)</code> wrapper</li> <li>Optional enums, strings, integers</li> <li>Empty string vs None semantics</li> <li>Cascading defaults &amp; fallback logic</li> </ul>"},{"location":"examples/optional_values/#running","title":"Running","text":"<pre><code>uv run python examples/optional_values.py\n</code></pre>"},{"location":"examples/optional_values/#generated-configini-excerpt","title":"Generated <code>config.ini</code> (Excerpt)","text":"<p>First run (only defaults materialize):</p> <pre><code>[OptionalConfig]\ndatabase_url = sqlite:///app.db\nlog_file = app.log\nworker_count = 4\noptional_string = default\noptional_int = 42\noptional_enum = dev\napi_key = \nsecret_key = \n\n[DatabaseConfig]\nconnection_string = sqlite:///fallback.db\nusername = \npassword = \nport = 5432\n</code></pre> <p>After code mutates values or sets some to <code>None</code>, lines representing <code>None</code> are removed (or may remain absent if never set). When assigning new values, those lines reappear.</p> <p>Example after updates:</p> <pre><code>[OptionalConfig]\ndatabase_url = \nlog_file = \nworker_count = \noptional_string = new value\noptional_int = 100\noptional_enum = prod\napi_key = \nsecret_key = \n\n[DatabaseConfig]\nconnection_string = postgresql://localhost/mydb\nusername = admin\npassword = \nport = 5433\n</code></pre>"},{"location":"examples/optional_values/#notes","title":"Notes","text":"<ul> <li>Setting a value to <code>None</code> for an optional field removes it from the config file.</li> <li>Empty string <code>\"\"</code> is distinct from <code>None</code> (still persisted as a blank value).</li> <li>Use fallback logic in application code (see <code>get_connection_params</code>).</li> </ul>"},{"location":"examples/optional_values/#try-variations","title":"Try Variations","text":"<ul> <li>Remove the whole <code>[DatabaseConfig]</code> section and re-run.</li> <li>Set <code>worker_count = None</code> then reassign an integer.</li> </ul>"},{"location":"reference/config/","title":"Config Descriptor","text":"<p>This section provides curated guidance around the core <code>Config</code> descriptor and its decorators. For full auto-generated API documentation see the pdoc pages linked via the <code>pdoc:</code> references below.</p>"},{"location":"reference/config/#core-class","title":"Core Class","text":"<ul> <li><code>Config</code> \u2013 Descriptor managing reading/writing typed values.</li> </ul>"},{"location":"reference/config/#lifecycle-initialization-helpers","title":"Lifecycle / Initialization Helpers","text":"<ul> <li><code>Config.set_parser</code></li> <li><code>Config.set_file</code></li> <li><code>Config.write</code></li> </ul>"},{"location":"reference/config/#runtime-flags","title":"Runtime Flags","text":"<ul> <li><code>Config.validate_types</code></li> <li><code>Config.write_on_edit</code></li> </ul>"},{"location":"reference/config/#decorators","title":"Decorators","text":"<ul> <li><code>Config.set</code> \u2013 Always set a value before calling a function.</li> <li><code>Config.default</code> \u2013 Set only when unset.</li> <li><code>Config.with_setting</code> \u2013 Inject an existing descriptor value as a kwarg.</li> <li><code>Config.with_kwarg</code> \u2013 (Named <code>with_kwarg</code> in code; often described as <code>with_kwarg</code>) inject by section/setting with optional rename &amp; default.</li> </ul>"},{"location":"reference/config/#internal-validation-selected","title":"Internal Validation (Selected)","text":"<ul> <li><code>Config.validate_file</code></li> <li><code>Config.validate_parser</code></li> <li><code>Config.validate_strict_type</code></li> </ul> <p>Tip: Use the decorators for imperative flows and prefer descriptor attributes for normal configuration access.</p>"},{"location":"reference/data_types/","title":"Data Types","text":"<p>confkit uses a family of small converter classes to provide type safety and round\u2011trip serialization.</p>"},{"location":"reference/data_types/#base-type","title":"Base Type","text":"<ul> <li><code>BaseDataType</code></li> <li><code>BaseDataType.convert</code></li> <li><code>BaseDataType.validate</code></li> <li><code>BaseDataType.cast</code></li> <li><code>BaseDataType.cast_optional</code></li> </ul>"},{"location":"reference/data_types/#primitive-converters","title":"Primitive Converters","text":"<ul> <li><code>String</code></li> <li><code>Integer</code></li> <li><code>Float</code></li> <li><code>Boolean</code></li> <li><code>NoneType</code></li> </ul>"},{"location":"reference/data_types/#enum-converters","title":"Enum Converters","text":"<ul> <li><code>Enum</code></li> <li><code>StrEnum</code></li> <li><code>IntEnum</code></li> <li><code>IntFlag</code></li> </ul>"},{"location":"reference/data_types/#number-representation-helpers","title":"Number Representation Helpers","text":"<ul> <li><code>Hex</code></li> <li><code>Octal</code></li> <li><code>Binary</code></li> </ul>"},{"location":"reference/data_types/#optional-composite","title":"Optional &amp; Composite","text":"<ul> <li><code>Optional</code></li> <li><code>List</code></li> </ul> <p>Design note: <code>Optional</code> wraps another <code>BaseDataType</code> and returns <code>None</code> when a null sentinel is parsed.</p>"},{"location":"reference/data_types/#custom-type-example","title":"Custom Type Example","text":"<ul> <li><code>BaseDataType</code></li> </ul>"},{"location":"reference/exceptions/","title":"Exceptions","text":"<p>The library raises a small, focused set of exceptions for invalid defaults and converter errors.</p> <ul> <li><code>InvalidDefaultError</code></li> <li><code>InvalidConverterError</code></li> </ul> <p>These both subclass <code>ValueError</code> to keep failure modes familiar while allowing precise catching.</p>"}]}